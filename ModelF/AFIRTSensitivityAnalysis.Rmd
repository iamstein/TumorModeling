---
title: "Analysis of Model F"
author: "IMA tumor modeling team"
date:  '`r format(Sys.time(), "%d %B, %Y")`'
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---

### Analysis on Model F

```{r warning=FALSE}
suppressMessages(source("ams_initialize_script.R"))
suppressMessages(library(RxODE))
suppressMessages(library(dplyr))
```

# Model F is defined below

```{r}
source("ivsc_4cmtct_shedct.R")
source("AFIRT_calculation.R")
```
```{r}
# Global Variables
model = ivsc_4cmtct_shedct()
tmax  = 10*28 # End of the observation time, unit=day
tau   = 1 # dosing interval, unit=day
compartment = 2 # compartment to which dosing is applied

# Import parameters
d = readxl::read_excel("../data/ivsc_4cmtct_shedct_param.xlsx",1)
param.as.double = d$Value
names(param.as.double) = d$Parameter

# Helper function to make the range of a variable when performing sensitivity analysis
lseq = function(from, to, length.out){
    sequence = seq(log(from), log(to), length.out=length.out)
    sequence = exp(sequence)
    return(sequence)
}
```

# The function below calculates AFIRT from theory

Argument: dose amount in nmol
Return:   theoretical AFIRT for both Kss and Kd

```{r}
AFIRT_theory = function(dose.nmol){
    p = as.data.frame(t(param.as.double))
    Kss = with(p, (koff3 + keDM3 + kshedM3)/kon3)
    Kd = with(p, koff3 / kon3)
    
    # numerator and denomenator for Mtot3.ss(Mtot3 at steady state)
    numerator   = with(p, k13DM*(VD1/VD3)*ksynM1+(keDM1+kshedM1+k13DM)*ksynM3)
    denomenator = with(p, (keDM1+kshedM1+k13DM)*(keDM3+kshedM3+k31DM)-k31DM*k13DM)
    Mtot3.ss = numerator / denomenator

    # numerator and denomenator for M3.0 (M3 at initial state)
    numerator   = with(p, k13M*(VD1/VD3)*ksynM1+(keM1+kshedM1+k13D)*ksynM3)
    denomenator = with(p, (keM1+kshedM1+k13D)*(keD3+kshedM3+k31D)-k31D*k13D)
    M3.0 = numerator / denomenator

    # Target accumulation in the tumor compartment
    Tacc.tum = Mtot3.ss / M3.0

    CL = with(p, keD1 * VD1)
    B  = with(p, (k13D*VD1/VD3)/(keD3 + k31D))
      
    AFIRT.theory.Kss = Kss*Tacc.tum*(CL*tau)/(dose.nmol*B)
    AFIRT.theory.Kd  = Kd*Tacc.tum*(CL*tau)/(dose.nmol*B)
    return(c(AFIRT.theory.Kss, AFIRT.theory.Kd))
}
```

# The function below simulates AFIRT as the average of free target to initial target

Argument: dose amount in nmol
Return:   simulated AFIRT

Note: This function computes AFIRT as the average of M3/M3.0 when time is in (56, 84).

```{r}
AFIRT_sim = function(dose.nmol){
  ev = eventTable(amount.units="nmol", time.units="days")
  sample.points = c(seq(-7, tmax, 0.1), 10^(-3:0)) # sample time, increment by 0.1
  sample.points = sort(sample.points)
  sample.points = unique(sample.points)
  ev$add.sampling(sample.points)
  ev$add.dosing(dose=dose.nmol, nbr.doses=floor(tmax/tau)+1, dosing.interval=tau,
                dosing.to=2)
      
  init = model$init(param.as.double)
  out = model$rxode$solve(param.as.double, ev, init)
  out = model$rxout(out)
  out = out %>% 
    mutate(Sfree.pct = S1/init["S1"],
             Mfree.pct = M3/init["M3"],
             dose.nmol = dose.nmol)
    
  last.two.doses = out %>%
    filter(time > 2*28 & time < 3*28)

  AFIRT.sim = mean(last.two.doses$Mfree.pct)

  return(AFIRT.sim)
}
```

# The function below performs sensitivity analysis for AFIRT

Argument:\break
    dose.nmol: dose amount in nmol\break
    variable:  the name of the variable you want to vary, e.g. kshedM3, kon3, koff3 etc\break
    range:     the range of the variable, typically the return of lseq function\break
Return:
    A data frame with columns: <variable>, AFIRT.sim, AFIRT.theory.Kss, AFIRT.theoy.Kd
    Each row correspond to a particular value of <variable>
    
```{r}
sensitivity_analysis_for_AFIRT = function(dose.nmol, variable, range){
    df = data.frame()
    for (value in range){
        param.as.double[variable] = value
        AFIRT.sim = AFIRT_sim(dose.nmol)
        AFIRT.theory = AFIRT_theory(dose.nmol)
        row = append(c(value, AFIRT.sim), AFIRT.theory)
        df = rbind(df, row)
    }
    colnames(df) = c(variable, "AFIRF.sim", "AFIRT.theory.Kss", "AFIRT.theory.Kd")  
    return(df)
}
```

# This function plots the sensitivity analysis for AFIRT

Basically, it puts the data frame returned from sensitivity\_analysis\_for\_AFIRT onto a picture

```{r}
plot.AFIRT.sensitivity.analysis = function(data, filename){
    names = names(data)
    data = data %>% gather(key, value, -c(get(names[1])))
    g = ggplot(data, aes(get(names[1]), value, color=key)) +
        scale.x.log10() +
        scale.y.log10() +
        geom_point() +
        geom_line() +
        ylab("AFIRT") + 
        xlab(names[1])
    ggsave(filename, g)
    return(g)
}
```

# This fuction simulates Model F

Argument:
    dose.nmol:        dose amount in nmol
    params_file_path: full path of the parameter file
Return:
    A data frame containing all the compartments of the model

Note: dose amount is sent to the second compartment (or the second differential equation)

```{r}
simulation = function(dose.nmol, params_file_path){
  d <- xlsx::read.xlsx(params_file_path, 1)
  param.as.double = d$Value
  names(param.as.double) = d$Parameter
  ev = eventTable(amount.units="nmol", time.units="days")
  sample.points = c(seq(-7, tmax, 0.1), 10^(-3:0)) # sample time, increment by 0.1
  sample.points = sort(sample.points)
  sample.points = unique(sample.points)
  ev$add.sampling(sample.points)
  ev$add.dosing(dose=dose.nmol, nbr.doses=floor(tmax/tau)+1, dosing.interval=tau,
                dosing.to=2)
      
  init = model$init(param.as.double)
  out = model$rxode$solve(param.as.double, ev, init)
  out = model$rxout(out)
  out = out %>% 
    mutate(Sfree.pct = S1/init["S1"],
             Mfree.pct = M3/init["M3"],
             dose.nmol = dose.nmol)
  return(out)
}

dose.nmol = 80
df = simulation(dose.nmol, "../data/ModelF_Atezolizumab_Params.xlsx")
```

# Here is how the simulated output looks like for time > 0

```{r}
dose_applied = df %>%
  filter(time >0)
dose_applied %>%
  head(5) %>%
  signif(2) %>%
  kable()
```

# D1 (drug) against time

```{r}
g = ggplot(df, aes(time, D1)) + geom_point()
print(g)
```

# D3 (drug) against time

```{r}
g = ggplot(df, aes(time, D3)) + geom_point()
print(g)
```

# DM3 (complex) against time

```{r}
g = ggplot(df, aes(time, DM3)) + geom_point()
print(g)
```

# M3 (free target) against time

```{r}
g = ggplot(df, aes(time, M3)) + geom_point()
print(g)
```

# Mfree (free target to initial target) against time

```{r}
g = ggplot(df, aes(time, Mfree.pct)) + geom_point()
print(g)
```

# Mtot3 (total free target) against time

```{r}
g = ggplot(df, aes(time, Mtot3)) + geom_point() + ylim(0, 3)
print(g)
```

## Perform sensitivity analysis for AFIRT on dose.nmol

```{r}
sensitivity_analysis_wrt_dose.nmol = function(dose.nmol.range){
  df = data.frame()
  for (dose.nmol in dose.nmol.range){
    AFIRT.sim = AFIRT_sim(dose.nmol=dose.nmol)
    AFIRT.theory = AFIRT_theory(dose.nmol = dose.nmol) 
    row = append(c(dose.nmol, AFIRT.sim), AFIRT.theory)
    df = rbind(df, row)
  }
  colnames(df) = c("dose.nmol", "AFIRT.sim", "AFIRT.theory.Kss", "AFIRT.theory.Kd")
  return(df)
}

dose.nmol.range = lseq(1, 100000, 20)
df = sensitivity_analysis_wrt_dose.nmol(dose.nmol.range = dose.nmol.range)
kable(signif(df,2))
```

## Make a plot of the above data frame

```{r}
plot.AFIRT.sensitivity.analysis(df, "AFIRTwrtdose.jpg")
```

#  AFIRT sensitivity analysis on kshedM3

kshedM3 = 3 in the parameter file
set range of kshedM3 to be [1, 10] with 6 folds

```{r}
sen = sensitivity_analysis_for_AFIRT(dose.nmol=80, variable="kshedM3", range = lseq(1, 10 ,6))
plot.AFIRT.sensitivity.analysis(sen, "AFIRTwrtkshedM3.jpg")
```

# AFIRT sensitivity analysis on VD3 (tumor size)
VD3 = 0.1 in the parameter file
set range of VD3 to be [0.01, 1] with 6 folds

```{r}
sen = sensitivity_analysis_for_AFIRT(dose.nmol=80, variable="kshedM3", range = lseq(0.01, 1, 6))
plot.AFIRT.sensitivity.analysis(sen, "AFIRTwrtVD3.jpg")
```

# Test the theory and simulation of the lumped parameters: M30, M3tot.ss, B, Davg3 

## The function below takes a dataset and calculate these lumped parameters from theory

Argument: params_file_path: path to the parameters file
Return:   data frame of lumped parameter calcuated from theory

```{r}
lumped.parameters.theory = function(dose.nmol=dose.nmol,params_file_path){
    d <- xlsx::read.xlsx(params_file_path, 1)
    param.as.double = d$Value
    names(param.as.double) = d$Parameter
    p = as.data.frame(t(param.as.double))
    Kss = with(p, (koff3 + keDM3 + kshedM3)/kon3)
    Kd = with(p, koff3 / kon3)
    
    # numerators for M3.0 and Mtot3.ss(Mtot3 at steady state, M3 at initial state)
    numerator.DM   = with(p, k13DM*(VD1/VD3)*ksynM1+(keDM1+kshedDM1+k13DM)*ksynM3)
    denomenator.DM = with(p, (keDM1+kshedDM1+k13DM)*(keDM3+kshedM3+k31DM)-k31DM*k13DM)
    
    numerator.M    = with(p, k13M *(VD1/VD3)*ksynM1+(keM1 +kshedM1 +k13M) *ksynM3)
    denomenator.M  = with(p, (keM1 +kshedM1 +k13M) *(keM3 +kshedM3+k31M) -k31M *k13M)
    
    # numerator and denomenator for M3.0 ()
    Mtot3.ss = numerator.DM / denomenator.DM
    M30      = numerator.M  / denomenator.M

    # Target accumulation in the tumor compartment
    Tacc.tum = Mtot3.ss / M30

#    CL = with(p, keD1 / VD1)
#    B = with(p, (k13D*VD1/VD3)/(keD3 + k31D))
    
    CL = with(p, keD1 * VD1)
    B  = with(p, (k13D*VD1/VD3)/(keD3 + k31D))
    
    Davg1 = dose.nmol/(CL*tau)
    Davg3 = B*Davg1
    
    AFIRT.Kss = Kss*Tacc.tum/Davg3
    AFIRT.Kd  = Kd*Tacc.tum/Davg3
    
    lumped_parameters_theory = data.frame(type = "theory",
                                          dose.nmol=dose.nmol,
                                          M30=M30, 
                                          Mtot3.ss=Mtot3.ss, 
                                          Tacc.tum=Tacc.tum,
                                          Davg1 = Davg1,
                                          Davg3 = Davg3,
                                          AFIRT.Kss = AFIRT.Kss,
                                          AFIRT.Kd  = AFIRT.Kd)
#    lumped_parameters_theory = data.frame(lumped_parameters_theory)
#    names(lumped_parameters_theory) = c("M30", "Mtot3.ss", "Target Accumulation Rate")
    return(lumped_parameters_theory)
}
```

## Calculate lumped parameters from theory for Atezolizumab

```{r}
dose.nmol = 80000
lumped_parameters_theory = lumped.parameters.theory(dose.nmol,"../data/ModelF_Atezolizumab_Params.xlsx")
kable(lumped_parameters_theory)
```

## The function below computes the lumped parameters from simulation

Argument:
  dose.nmol:        The dose amount in nmol
  params_file_path: path to the parameter file
Return: 
  A data frame of simulated lumped parameters

```{r}
dose.nmol = 80000
lumped.parameters.simulation = function(dose.nmol, params_file_path){
  sim = simulation(dose.nmol=dose.nmol, params_file_path = params_file_path)
  initial_state = sim %>%
    filter(time==0)
  M30 = initial_state$M3
  
  steady_state = sim %>%
    filter(time>9*28)# & time <3*28)
  Mtot3.ss = mean(steady_state$Mtot3)
  Davg1    = mean(steady_state$Dtot1)
  Davg3    = mean(steady_state$Dtot3)
  M3       = mean(steady_state$M3)

  Tacc.tum = Mtot3.ss / M30
  
  lumped_parameters_sim = data.frame(type = "simulation",
                                     dose.nmol = dose.nmol,
                                     M30=M30, 
                                     Mtot3.ss=Mtot3.ss, 
                                     Tacc.tum=Tacc.tum,
                                     Davg1 = Davg1,
                                     Davg3 = Davg3,
                                     AFIRT = M3/M30)
  return(lumped_parameters_sim)
}
```

For sanity check, the lumped parameters M30, Mtot3.ss, and Tacc.tum  should not depends on the initial dose amount.
For different dose amount, the function lumped.parameters.simulation should return the same data frame.

```{r}
dose.range = c(80, 800, 8000, 80000)
for (dose.nmol in dose.range){
  lumped_parameters_sim = lumped.parameters.simulation(dose.nmol,   params_file_path="../data/ModelF_Atezolizumab_Params.xlsx")
#  kable(signif(lumped_parameters_sim,3))
}
```

Okay, for different inital doses, we do get the same simulated lumped parameters. However, M30 seems to be the same as Mtot3.ss
in the simulation which is kind of weird. Also, M30 calculated from theory and M30 calculated from simulation are off by a lot.

* Andy says: the parameetrs are such that M3tot doesn't accumulate much. So this makes sense. We compare the theory and simulation below.

* kable is not working for lumped_parameters_sim or lumped_parameters_theory.

```{r warning=FALSE}
  comparison = bind_rows(lumped_parameters_sim,lumped_parameters_theory)
  kable(comparison)
```
#### Check initial values
The initial values (S10, M10, M30) from the simulation should agree with the the ones provided
from the dataset 
```{r}



























